<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Lab_Automation.devices.stellarnet_spectrometer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Lab_Automation.devices.stellarnet_spectrometer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># from typing import Union, Tuple, Dict, List, Optional
# from datetime import datetime

# import numpy as np
# import pandas as pd
# from scipy.interpolate import interp1d
# from scipy.optimize import minimize
# import stellarnet_driver3 as sn

# from .device import Device, check_initialized

# # TOD
# # convert to serial device parent when arduino added
# # add shutter and lamp control
# # check slicing as second index is not included in slice
# # type hinting of ndarrays?
# # type hint the static methods?

# class StellarNetSpectrometer(Device):
#     save_directory = &#39;data/spectroscopy/&#39;

#     def __init__(self, name: str, spec_keys: List[str] = [&#39;UV-Vis&#39;, &#39;NIR&#39;]):
#         super().__init__(name)
#         self.spectrometer_dict = {}
#         self.wavelength_dict = {}
#         self.dark_spectra_dict = {}
#         self.blank_spectra_dict = {}
#         self.absorbance_dict = {}
#         self.merged_absorbance = None
#         self.num_spectrometers = 0
#         self.spec_keys = spec_keys

#     @staticmethod
#     def num_specs_connected() -&gt; int:
#         num_connected = 0
#         start_wav = [-1.]
#         while True:
#             try:
#                 spec, wav = sn.array_get_spec(num_connected)
#                 start_wav.append(wav[0].item())
#                 if start_wav[num_connected+1] == start_wav[num_connected]:
#                     break
#                 else:
#                     num_connected += 1
#             except:
#                 break
#         return num_connected

#     def initialize(self) -&gt; Tuple[bool, str]:
#         #lamp on
#         #shutter in/out
#         #any other Arduino initialization

#         self.num_spectrometers = self.num_specs_connected()
#         if self.num_spectrometers == 0:
#             self._is_initialized = False
#             return (False, &#34;There are no spectrometers connected&#34;)

#         for ndx in range(self.num_spectrometers):
#             spectrometer, wavelengths = sn.array_get_spec(ndx)
#             if wavelengths[0] &lt; 200.0:
#                 # UV-VIS
#                 self.spectrometer_dict[&#39;UV-Vis&#39;] = spectrometer
#                 self.wavelength_dict[&#39;UV-Vis&#39;] = wavelengths
#             else:
#                 # NIR
#                 self.spectrometer_dict[&#39;NIR&#39;] = spectrometer
#                 self.wavelength_dict[&#39;NIR&#39;] = wavelengths
#             # For additional spectrometers add to the if else ladder

#         # Check that we were able to initialize all spectrometers that were declared during construction
#         if set(self.spec_keys) == set(self.spectrometer_dict.keys()):        
#             self._is_initialized = True
#             return (True, &#34;Successfully initialized &#34; + str(self.num_spectrometers) + &#34; spectrometers: &#34; + str(list(self.spectrometer_dict.keys())))
#         else:
#             self._is_initialized = False
#             return (False, &#34;Not all declared spectrometers were initialized. Only initialized: &#34; + str(list(self.spectrometer_dict.keys())))

#     def deinitialize(self, reset_init_flag: bool = True) -&gt; Tuple[bool, str]:
#         # turn off lamp?
#         # move shutter the position  so that initialize can  be ready to move the shutter  correct position when starting the instrument
#         if reset_init_flag:
#             self._is_initialized = False

#         return (True, &#34;Pass, nothing to deinitialize for now.&#34;)

#     @check_initialized
#     def get_spectrum_counts(
#             self, 
#             spec_key: str, 
#             integration_time: int = 100, 
#             scans_to_avg: int = 3,  
#             smoothing: int = 0, 
#             xtiming: int = 1) -&gt; Tuple[bool, str]:

#         # if not self._is_initialized:
#         #     return (False, &#34;Spectrometer system not initialized&#34;)

#         if spec_key in self.spectrometer_dict.keys():
#             self.spectrometer_dict[spec_key][&#39;device&#39;].set_config(
#                 int_time=integration_time, 
#                 scans_to_avg=scans_to_avg, 
#                 x_smooth=smoothing, 
#                 x_timing=xtiming)

#             spectrum_array = sn.array_spectrum(self.spectrometer_dict[spec_key], self.wavelength_dict[spec_key])

#             max_count = np.amax(spectrum_array[:,1], axis=0)
#             print(&#34;Max count: &#34; + str(max_count))
#             if max_count &gt; 65500:
#                 return (False, spec_key + &#34; detector is saturated, lower integration time&#34;)
#             return (True, spectrum_array)
#         else:
#             return (False, spec_key + &#34; spectrometer is not found&#34; )

#     def get_all_spectra_counts(
#             self, 
#             integration_times: Tuple[int, ...] = (100, 100), 
#             scans_to_avg: Tuple[int, ...] = (3, 3), 
#             smoothings: Tuple[int, ...] = (0, 0), 
#             xtimings: Tuple[int, ...] = (1, 1)) -&gt; Tuple[bool, str]:

#         # Modify the variable &#39;spec_keys&#39; if you don&#39;t intend to use all spectrometers
#         if self.num_spectrometers != len(self.spec_keys):
#             return (False, &#34;Spectrometers are not all connected&#34;)

#         spectrum_array_dict = {}
#         # print(spec_keys)
#         # using self.spec_keys to ensure that the order within the parameter tuple matches the order of the declared spec_keys
#         for ndx, spec_key in enumerate(self.spec_keys):
#             # this function should already check if the spec_key is valid
#             result, spectrum_array = self.get_spectrum_counts(
#                                         spec_key,
#                                         integration_time=integration_times[ndx], 
#                                         scans_to_avg=scans_to_avg[ndx], 
#                                         smoothing=smoothings[ndx], 
#                                         xtiming=xtimings[ndx])
#             if not result:
#                 return result, spectrum_array

#             spectrum_array_dict[spec_key] = spectrum_array

#         return (True, spectrum_array_dict)


#     def update_all_dark_spectra(
#             self, 
#             integration_times: Tuple[int, ...] = (100, 100), 
#             scans_to_avg: Tuple[int, ...] = (3, 3), 
#             smoothings: Tuple[int, ...] = (0, 0), 
#             xtimings: Tuple[int, ...] = (1, 1)) -&gt; Tuple[bool, str]:

#         result, spectrum_array_dict = self.get_all_spectra_counts(
#                                         integration_times, 
#                                         scans_to_avg, 
#                                         smoothings, 
#                                         xtimings)

#         if not result:
#             return result, spectrum_array_dict

#         for key, value in spectrum_array_dict.items():
#             self.dark_spectra_dict[key] = value

#         return (True, &#34;All dark spectra stored&#34;)

#     def update_all_blank_spectra(
#             self, 
#             integration_times: Tuple[int, ...] = (100, 100), 
#             scans_to_avg: Tuple[int, ...] = (3, 3), 
#             smoothings: Tuple[int, ...] = (0, 0), 
#             xtimings: Tuple[int, ...] = (1, 1)) -&gt; Tuple[bool, str]:

#         result, spectrum_array_dict = self.get_all_spectra_counts(
#                                         integration_times, 
#                                         scans_to_avg, 
#                                         smoothings, 
#                                         xtimings)

#         if not result:
#             return result, spectrum_array_dict

#         for key, value in spectrum_array_dict.items():
#             self.blank_spectra_dict[key] = value

#         return (True, &#34;All blank spectra stored&#34;)

#     def get_all_absorbance(
#             self,
#             save_to_file: bool = False, 
#             filename: Optional[str] = None,
#             integration_times: Tuple[int, ...] = (100, 100), 
#             scans_to_avg: Tuple[int, ...] = (3, 3), 
#             smoothings: Tuple[int, ...] = (0, 0), 
#             xtimings: Tuple[int, ...] = (1, 1)) -&gt; Tuple[bool, str]:

#         # get the sample spectra
#         result, spectrum_array_dict = self.get_all_spectra_counts(
#                                         integration_times, 
#                                         scans_to_avg, 
#                                         smoothings, 
#                                         xtimings)
#         if save_to_file and filename is None:
#             timestamp = datetime.now().strftime(&#39;%Y%m%d_%H%M%S&#39;)
#             filename = timestamp


#         # check if failed
#         if not result:
#             return result, spectrum_array_dict

#         # check that dark/blank spectra exists for each initialized spectrometer
#         for key in self.spectrometer_dict.keys():
#             if not key in self.blank_spectra_dict:
#                 return (False, &#34;Blank spectra for &#34; + key + &#34; is missing&#34;)
#             if not key in self.dark_spectra_dict:
#                 return (False, &#34;Dark spectra for &#34; + key + &#34; is missing&#34;)

#         # Calculate absorbance for each spectra, save to self
#         # Absorbance is -log10((Isample - Idark)/(Iblank - Idark))
#         for ndx, spec_key in enumerate(self.spec_keys):
#             wavelength = self.wavelength_dict[spec_key].copy()
#             dark_spec = self.dark_spectra_dict[spec_key][:,1].copy()
#             blank_spec = self.blank_spectra_dict[spec_key][:,1].copy()
#             sam_spec = spectrum_array_dict[spec_key][:,1].copy()

#             absorbance = np.expand_dims(-np.log10((sam_spec - dark_spec) / (blank_spec - dark_spec)), axis=1)
#             absorbance_array = np.hstack((wavelength, absorbance))

#             self.absorbance_dict[spec_key] = absorbance_array
            
#             # save all data related to absorbance calculation to a file per spectrometer
#             if save_to_file:
#                 data = pd.DataFrame()
#                 data[spec_key + &#39; Wavelength&#39;] = np.squeeze(wavelength)
#                 data[spec_key + &#39; Dark Counts&#39;] = np.squeeze(dark_spec)
#                 data[spec_key + &#39; Blank Counts&#39;] = np.squeeze(blank_spec)
#                 data[spec_key + &#39; Sample Counts&#39;] = np.squeeze(sam_spec)
#                 data[spec_key + &#39; Absorbance&#39;] = np.squeeze(absorbance)
                
#                 comment = [&#34;# spec_key = &#34; + spec_key + &#34;\n&#34;,
#                             &#34;# integration_time = &#34; + str(integration_times[ndx]) + &#34;\n&#34;,
#                             &#34;# scans_to_avg = &#34; + str(scans_to_avg[ndx]) + &#34;\n&#34;,
#                             &#34;# smoothing = &#34; + str(smoothings[ndx]) + &#34;\n&#34;,
#                             &#34;# xtiming = &#34; + str(xtimings[ndx]) + &#34;\n&#34;]
                
#                 fullfilename = self.save_directory + filename + &#39;_&#39; + spec_key + &#39;.csv&#39;
#                 with open(fullfilename, &#39;w&#39;) as file:
#                     file.writelines(comment)
#                 data.to_csv(fullfilename, mode=&#39;a&#39;, index_label=&#39;Index&#39;)

#         if save_to_file:
#             all_comments = [&#34;# spec_keys = &#34; + str(self.spec_keys) + &#34;\n&#34;
#                             &#34;# integration_times = &#34; + str(integration_times) + &#34;\n&#34;,
#                             &#34;# scans_to_avg = &#34; + str(scans_to_avg) + &#34;\n&#34;,
#                             &#34;# smoothings = &#34; + str(smoothings) + &#34;\n&#34;,
#                             &#34;# xtimings = &#34; + str(xtimings) + &#34;\n&#34;]
#         else:
#             all_comments = [&#39;#\n&#39;,]
#         # Merge the absorbance spectra and optionally save to file
#         # What happens if only 1 spectrometer is connected/being used?
#         if len(self.spec_keys) &gt; 1:
#             result, message = self.merge_absorbance(save_to_file, filename, all_comments)

#             if not result:
#                 return result, message

#         if save_to_file:
#             return (True, &#34;All absorbance spectra stored to instance and saved to file: &#34; + self.save_directory + filename)
#         else:
#             return (True, &#34;All absorbance spectra stored to instance but not saved to file&#34;)

#     # hard coded for UV-Vis and NIR
#     # what happens if only 1 spectrometer is connected/being used?
#     def merge_absorbance(self, save_to_file: bool, filename: str, comment_list: List[str]) -&gt; Tuple[bool, str]:
#         uv_wavelength = np.squeeze(self.wavelength_dict[&#39;UV-Vis&#39;].copy())
#         nir_wavelength = np.squeeze(self.wavelength_dict[&#39;NIR&#39;].copy())
#         uv_absorbance = np.squeeze(self.absorbance_dict[&#39;UV-Vis&#39;][:,1].copy())
#         nir_absorbance = np.squeeze(self.absorbance_dict[&#39;NIR&#39;][:,1].copy())

#         # start and end of overlapping regions
#         WAVE_START = 900.0
#         WAVE_END = 1030.0

#         merge_result = minimize(self.merge_error, [1, 0], args=(uv_wavelength, uv_absorbance, nir_wavelength, nir_absorbance, WAVE_START, WAVE_END), method=&#39;BFGS&#39;)

#         if not merge_result:
#             return (False, &#34;Failed to merge UV-Vis and NIR absorbance spectra: &#34; + merge_result.message)
#         else:
#             scale = merge_result.x[0]
#             shift = merge_result.x[1]

#             # uv is not modified, nir is adjusted to match uv
#             uv_array = self.absorbance_dict[&#39;UV-Vis&#39;].copy()
#             nir_wavelength = self.wavelength_dict[&#39;NIR&#39;].copy()

#             nir_absorbance = np.expand_dims(self.scale_shift_data([scale, shift], self.absorbance_dict[&#39;NIR&#39;][:,1].copy()), axis=1)
#             nir_array = np.hstack((nir_wavelength, nir_absorbance))

#             UV_START = 210.0
#             UV_END = 1030.0
#             NIR_START = 900.0
#             NIR_END = 1700.0

#             uv_array = self.truncate_ends_by_wavelength(uv_array, UV_START, UV_END)
#             nir_array = self.truncate_ends_by_wavelength(nir_array, NIR_START, NIR_END)

#             merged_array = np.vstack((uv_array, nir_array))
#             merged_array = merged_array[merged_array[:,0].argsort()]
#             self.merged_absorbance = merged_array
            
#             if save_to_file:
#                 data = pd.DataFrame()
#                 data[&#39;Wavelength&#39;] = np.squeeze(self.merged_absorbance[:,0].copy())
#                 data[&#39;Absorbance&#39;] = np.squeeze(self.merged_absorbance[:,1].copy())

#                 fullfilename = self.save_directory + filename + &#39;_merged.csv&#39;
#                 comment_list.append(&#34;# To merge, NIR data is scaled first then shifted\n&#34;)
#                 comment_list.append(&#34;# scale = &#34; + str(scale) + &#34;\n&#34;)
#                 comment_list.append(&#34;# shift = &#34; + str(shift) + &#34;\n&#34;)
#                 with open(fullfilename, &#39;w&#39;) as file:
#                     file.writelines(comment_list)
#                 data.to_csv(fullfilename, mode=&#39;a&#39;, index_label=&#39;Index&#39;)

#             return (True, &#34;Successfully merged UV-Vis and NIR absorbance spectra: &#34; + merge_result.message)

#     # y and return are ndarrays
#     @staticmethod
#     def scale_shift_data(params: List[float], y):
#         scale = params[0]
#         shift = params[1]
#         return y * scale + shift
#         # return (y + shift) * scale

#     @staticmethod
#     def truncate_ends_by_wavelength(array, start: float, end: float):
#         # expects array to be two columns with first being wavelength and second being the data of interest (counts, absorbance, etc.)
#         return array[np.logical_and(array[:,0]&gt;start, array[:,0]&lt;end)]

#     @staticmethod
#     def find_nearest(x, x0):
#         ndx = np.abs(x - x0).argmin()
#         return ndx, x[ndx]

#     @staticmethod
#     def merge_error(params, x1, y1, x2, y2, x_start, x_end):
#         # y1 (UV-Vis) has higher resolution (2048) than y2 (NIR, 512)
#         # so although we will adjust y2 to match y1, y1 will be interpolated onto x2
#         # get the overlapped slice of the data that is not being interpolated (x2)
#         x2_start_ndx = StellarNetSpectrometer.find_nearest(x2, x_start)[0]
#         x2_end_ndx = StellarNetSpectrometer.find_nearest(x2, x_end)[0]
#         x2_slice = x2[x2_start_ndx : x2_end_ndx].copy()
#         # adjust y2
#         new_y2 = StellarNetSpectrometer.scale_shift_data(params, y2)
#         y2_slice = new_y2[x2_start_ndx : x2_end_ndx].copy()
#         # get interpolated function of y1(x1)
#         y1_interp = interp1d(x1, y1)
#         # get y1 interpolated onto x2
#         y1_slice = y1_interp(x2_slice)
#         # calc error
#         sum_squares = ((y1_slice - y2_slice) ** 2).sum()
#         return sum_squares

#     def servo_shutter_in(self):
#         pass

#     def servo_shutter_out(self):
#         pass

#     def lamp_relay_on(self):
#         pass

#     def lamp_relay_off(self):
#         pass


# # Considered making get_spectrum_counts generalized to accept either a single spectrometer (spec_key + params) 
# # or any sized list of spec_keys + list of params.
# # I ended up not doing it this way and making get_spectrum_counts take only 1 spectrometer
# # Then I made a second function get_all_spectra_counts that calls get_spectrum_counts multiple times.
# # My subsequent functions to get dark spectra, blank spectra, absorbance spectra then work with get_all_spectra_counts
# # At first this seems more complicated. However, I did it to avoid list/tuple type checking and len() checking for every single param
# # and because I wanted to avoid the following situation:
# # 1) User gets dark and blank spectra for all spectrometers and proceeds to use them to get absorption spectras
# # 2) Later, user needs needs to retake the dark/blank spectra but makes an error and uses the generalized methods for NOT all spectrometers
# # 3) User proceeds to calculate all absorption spectra for all spectrometers
# # In this case, not all spectrometers had their dark/blank spectra correctly retaken.
# # The data is then incorrect for those spectrometers since they use the old dark/blank but the user has no idea this just happened.
# # Another option is to null all spectrometer dark/blanks when even only retaking for 1 spectrometer, but requires implementing checks and error messages
# # It is easier at the moment to just enforce all spectrometers are used all the time by writing methods that always use all spectrometers
# # However, The &#34;get_all_...&#34; methods can generalize to 1 spectrometer based on the spec_keys arg passed during construction</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Lab_Automation.devices" href="index.html">Lab_Automation.devices</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>